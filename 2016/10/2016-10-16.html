<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="如何判断一个单向链表是否有环？"><title>October 16, 2016</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><base target="_blank" href="../../"><link rel="icon" type="image/x-ico" href="./images/favicon.ico"><link rel="stylesheet" type="text/css" href="css/tomorrow.css"><link rel="stylesheet" type="text/css" href="css/question.css"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-63581862-3', 'auto');
ga('send', 'pageview');</script><script type="application/javascript" src="js/d3.min.js"></script></head><body class="light"><header><h1>如何判断一个单向链表是否有环？</h1></header><ul class="tags"><li style="background-color: #C9CAEA">Algorithm</li><li style="background-color: #DDBADC">Data Structure</li></ul><main><p>算法不精也不熟，最先想到的总是最笨的方法，遍历，时间复杂度为 O(n<sup>2</sup>)。</p>
<p>后来 Google 一番，找到了 O(n) 的解决方案，很聪明（但也有种怎么也想不出来的感觉<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" enable-background="new 0 0 64 64"><circle cx="32" cy="32" r="30" fill="#ffdd67"/><path d="m40.6 46.4c-5.4-2.5-11.8-2.5-17.2 0-1.3.6.3 4.2 1.7 3.5 3.6-1.7 8.9-2.3 13.9 0 1.3.6 3-2.8 1.6-3.5" fill="#664e27"/><path d="m54 31c0 5-4 9-9 9-5 0-9-4-9-9 0-5 4-9 9-9 5 0 9 4 9 9" fill="#fff"/><circle cx="45" cy="31" r="6" fill="#664e27"/><g fill="#fff"><ellipse cx="46.6" cy="35.5" rx="2.8" ry="3.2"/><ellipse cx="42.8" cy="31" rx="1.6" ry="1.9"/><path d="m28 31c0 5-4 9-9 9-5 0-9-4-9-9 0-5 4-9 9-9 5 0 9 4 9 9"/></g><circle cx="19" cy="31" r="6" fill="#664e27"/><g fill="#fff"><ellipse cx="20.6" cy="35.5" rx="2.8" ry="3.2"/><ellipse cx="16.8" cy="31" rx="1.6" ry="1.9"/></g><path d="m47 36c-5.1 6.8-8 13-8 18.1 0 4.4 3.6 7.9 8 7.9 4.4 0 8-3.5 8-7.9 0-5.1-3-11.4-8-18.1" fill="#65b1ef"/><g fill="#917524"><path d="m53.2 20.7c-3.2-2.7-7.5-3.9-11.7-3.1-.6.1-1.1-2-.4-2.2 4.8-.9 9.8.5 13.5 3.6.6.5-1 2.1-1.4 1.7"/><path d="m22.5 17.4c-4.2-.7-8.5.4-11.7 3.1-.4.4-2-1.2-1.4-1.7 3.7-3.2 8.7-4.5 13.5-3.6.7.2.2 2.3-.4 2.2"/></g></svg>）。这个问题还有几个相关的问题：</p>
<ol>
<li>如何判断一个单向链表是否有环？</li>
<li>若有，环的入口在何方？</li>
<li>最后，环的长度与该单向链表的长度各是多少？</li>
</ol>
<p>借记录故，我来各自解答一番。</p>
<h3>如何判断一个单向链表是否有环</h3><p>一个单向链表如下，使用两个指针，一快（二倍速）一慢遍历该链表，在链表有环的情况下，它们总会相遇的。快指针总会追上慢指针，就像跑步一样。因此，若相遇，则有环；反之，快指针会跑到链表尾（null）。</p>
<h3>环的入口</h3><p><svg class='d3' id='example'  width='300' height='150'></svg></p>
<script type='text/javascript'>
var nodes = [{x: 10, y: 10},
  {x: 30, y: 10},
  {x: 50, y: 10, fill: 'red'},
  {x: 70, y: 10},
  {x: 70, y: 30, fill: 'yellow'},
  {x: 50, y: 30}]

var links = [{source: nodes[0], target: nodes[1], stroke: 'blue'},
  {source: nodes[1], target: nodes[2], stroke: 'blue'},
  {source: nodes[2], target: nodes[3]},
  {source: nodes[3], target: nodes[4]},
  {source: nodes[4], target: nodes[5], stroke: 'cyan'},
  {source: nodes[5], target: nodes[2], stroke: 'cyan'}]

var x = d3.scaleLinear().domain([0, 100]).range([0, 300])
var y = d3.scaleLinear().domain([0, 50]).range([0, 150])

d3.select('#example')
  .append('text')
  .attr('x', x(nodes[2].x))
  .attr('y', y(5))
  .attr('dx', '-.35em')
  .text('m')

d3.select('#example')
  .append('text')
  .attr('x', x(nodes[4].x + 5))
  .attr('y', y(nodes[4].y))
  .attr('dy', '.35em')
  .text('x')

d3.select('#example')
  .selectAll('line')
  .data(links)
  .enter()
  .append('line')
  .attr('x1', function(d) { return x(d.source.x) })
  .attr('y1', function(d) { return y(d.source.y) })
  .attr('x2', function(d) { return x(d.target.x) })
  .attr('y2', function(d) { return y(d.target.y) })
  .style('stroke', 'black')

d3.select('#example')
  .selectAll('circle')
  .data(nodes)
  .enter()
  .append('circle')
  .attr('cx', function(d) { return x(d.x) })
  .attr('cy', function(d) { return y(d.y) })
  .attr('r', 10)
  .attr('fill', function(d) { return d.fill || '#000' })

</script>

<p>假设链表长度为 n，入口在 m 处，环长度为 L。假设目前已经过 t 次循环，快指针走过路程为 2t，慢指针走过路程为 t。很容易想到，在极限状况下（首尾相连），相遇点总是在链表起点（此时 t = n），所以总能保证相遇时 t &lt;= n，也就是慢指针尚未遍历完链表，而快指针已经绕环 r（r &gt;= 1）圈了。</p>
<p>根据这些相互关系，我们可以得出算式：</p>
<blockquote>
<p>2t = t + Lr<br>t = Lr</p>
</blockquote>
<p>假设相遇点与碰撞点距离为 x，有：</p>
<blockquote>
<p>x + m = t = Lr = L * (r - 1) + L<br>x = L - m<br>m = L - x</p>
</blockquote>
<p>即<strong>起点至入口</strong>的距离为<strong>相遇点继续走到入口</strong>的距离。（也就是图中蓝色与青色的部分）</p>
<p><svg class='d3' id='example2' width='300' height='150'></svg></p>
<script type='text/javascript'>
d3.select('#example')
  .append('text')
  .attr('x', x(nodes[2].x))
  .attr('y', y(5))
  .attr('dx', '-.35em')
  .text('m')

d3.select('#example')
  .append('text')
  .attr('x', x(nodes[4].x + 5))
  .attr('y', y(nodes[4].y))
  .attr('dy', '.35em')
  .text('x')

d3.select('#example2')
  .selectAll('line')
  .data(links)
  .enter()
  .append('line')
  .attr('x1', function(d) { return x(d.source.x) })
  .attr('y1', function(d) { return y(d.source.y) })
  .attr('x2', function(d) { return x(d.target.x) })
  .attr('y2', function(d) { return y(d.target.y) })
  .style('stroke', function(d) { return d.stroke || 'black' })

d3.select('#example2')
  .selectAll('circle')
  .data(nodes)
  .enter()
  .append('circle')
  .attr('cx', function(d) { return x(d.x) })
  .attr('cy', function(d) { return y(d.y) })
  .attr('r', 10)
  .attr('fill', function(d) { return d.fill || 'black' })
</script>

<p>借助此特性，于起点与 x （相遇点）各设一个一倍速指针，它们会在 m （入口）相遇！</p>
<h3>环的长度与单向链表的长度</h3><p>找到了入口点，计算环的长度只需计算从入口点出发后第一次回到入口点的距离！</p>
<p>单向链表的长度 = 起点到入口点的距离 + 环的长度</p>
<h3>一个实现</h3><pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span><span class="hljs-params">(value)</span> {</span>
  this.value = value
  this.<span class="hljs-keyword">next</span> = null
}

<span class="hljs-keyword">let</span> oList = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>)
<span class="hljs-keyword">let</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">1</span>, tail = oList
// 之前我想用 top = oList，但浏览器报错，说 top 已经定义过。
// window 有 top / self / parent 属性，其含义暂略
// 我尝试给这三者赋值，只有 top 会报错，什么鬼<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" enable-background="new 0 0 64 64"><circle cx="32" cy="32" r="30" fill="#ffdd67"/><path d="m49.7 34.4c-.4-.5-1.1-.4-1.9-.4-15.8 0-15.8 0-31.6 0-.8 0-1.5-.1-1.9.4-3.9 5 .7 19.6 17.7 19.6 17 0 21.6-14.6 17.7-19.6" fill="#664e27"/><path d="m33.8 41.7c-.6 0-1.5.5-1.1 2 .2.7 1.2 1.6 1.2 2.8 0 2.4-3.8 2.4-3.8 0 0-1.2 1-2 1.2-2.8.3-1.4-.6-2-1.1-2-1.6 0-4.1 1.7-4.1 4.6 0 3.2 2.7 5.8 6 5.8 3.3 0 6-2.6 6-5.8-.1-2.8-2.7-4.5-4.3-4.6" fill="#4c3526"/><path d="m24.3 50.7c2.2 1 4.8 1.5 7.7 1.5 2.9 0 5.5-.6 7.7-1.5-2.1-1.1-4.7-1.7-7.7-1.7s-5.6.6-7.7 1.7" fill="#ff717f"/><path d="m47 36c-15 0-15 0-29.9 0-2.1 0-2.1 4-.1 4 10.4 0 19.6 0 30 0 2 0 2-4 0-4" fill="#fff"/><g fill="#65b1ef"><path d="m59.4 36.9c7.3 7.7-2.6 18.1-9.9 10.4-5.3-5.6-5.6-16.3-5.6-16.3s10.2.3 15.5 5.9"/><path d="m14.5 47.3c-7.3 7.7-17.2-2.7-9.9-10.4 5.3-5.6 15.5-5.9 15.5-5.9s-.3 10.7-5.6 16.3"/></g><g fill="#664e27"><path d="m28.5 28.7c-1.9-5.1-4.7-7.7-7.5-7.7s-5.6 2.6-7.5 7.7c-.2.5.8 1.4 1.3.9 1.8-1.9 4-2.7 6.2-2.7 2.2 0 4.4.8 6.2 2.7.6.5 1.5-.4 1.3-.9"/><path d="m50.4 28.7c-1.9-5.1-4.7-7.7-7.5-7.7s-5.6 2.6-7.5 7.7c-.2.5.8 1.4 1.3.9 1.8-1.9 4-2.7 6.2-2.7s4.4.8 6.2 2.7c.5.5 1.5-.4 1.3-.9"/></g></svg>
<span class="hljs-keyword">while</span> (<span class="hljs-built_in">count</span> &lt; <span class="hljs-number">6</span>) {
  tail.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">new</span> Node(++<span class="hljs-built_in">count</span>)
  tail = tail.<span class="hljs-keyword">next</span>
}
tail.<span class="hljs-keyword">next</span> = oList.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>

// 判断是否有环
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isCircular</span><span class="hljs-params">(head)</span> {</span>
  <span class="hljs-keyword">let</span> slow = head, fast = head

  <span class="hljs-keyword">while</span> (fast) {
    fast = fast.<span class="hljs-keyword">next</span>
    <span class="hljs-keyword">if</span> (!fast) <span class="hljs-keyword">return</span> false
    <span class="hljs-keyword">else</span> fast = fast.<span class="hljs-keyword">next</span>
    slow = slow.<span class="hljs-keyword">next</span>
    <span class="hljs-keyword">if</span> (slow === fast) <span class="hljs-keyword">return</span> true
  }

  <span class="hljs-keyword">return</span> false
}

// 找到入口点
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEntrance</span><span class="hljs-params">(head)</span> {</span>
  <span class="hljs-keyword">let</span> slow = head, fast = head, meet = null

  <span class="hljs-keyword">while</span> (fast) {
    fast = fast.<span class="hljs-keyword">next</span>
    <span class="hljs-keyword">if</span> (!fast) <span class="hljs-keyword">return</span> null
    fast = fast.<span class="hljs-keyword">next</span>
    slow = slow.<span class="hljs-keyword">next</span>
    <span class="hljs-keyword">if</span> (slow === fast) {
      meet = slow
      <span class="hljs-keyword">break</span>
    }
  }

  <span class="hljs-keyword">if</span> (!fast) <span class="hljs-keyword">return</span> null

  slow = head
  <span class="hljs-keyword">while</span> (slow !== meet) {
    slow = slow.<span class="hljs-keyword">next</span>
    meet = meet.<span class="hljs-keyword">next</span>
  }

  <span class="hljs-keyword">return</span> meet
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCircleLength</span><span class="hljs-params">(head)</span> {</span>
  <span class="hljs-keyword">let</span> entry = getEntrance(head)
  <span class="hljs-keyword">let</span> iterator = entry
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">ret</span> = <span class="hljs-number">0</span>
  <span class="hljs-keyword">do</span> {
    iterator = iterator.<span class="hljs-keyword">next</span>
    <span class="hljs-keyword">ret</span>++
  } <span class="hljs-keyword">while</span> (iterator !== entry)

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">ret</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getListLength</span><span class="hljs-params">(head)</span> {</span>
  <span class="hljs-keyword">let</span> entry = getEntrance(head)
  <span class="hljs-keyword">let</span> iterator = head
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">ret</span> = <span class="hljs-number">0</span>
  <span class="hljs-keyword">do</span> {
    iterator = iterator.<span class="hljs-keyword">next</span>
    <span class="hljs-keyword">ret</span>++
  } <span class="hljs-keyword">while</span> (iterator !== entry)

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">ret</span> + getCircleLength(head)
}

<span class="hljs-keyword">if</span> (isCircular(oList)) {
  console.<span class="hljs-built_in">log</span>(getEntrance(oList))     // Node { value: <span class="hljs-number">3</span>, nex<span class="hljs-variable">t:</span> [Object] }
  console.<span class="hljs-built_in">log</span>(getCircleLength(oList)) // <span class="hljs-number">4</span>
  console.<span class="hljs-built_in">log</span>(getListLength(oList))   // <span class="hljs-number">6</span>
}
</code></pre>
<h2 id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</h2><ol>
<li><a href="http://www.cnblogs.com/ccdev/archive/2012/09/06/2673618.html">判断单链表是否存在环及求环入口点</a></li>
</ol>
</main><aside><nav><ul><li><a class="index" href="archive.html" target="_self">List</a></li><li><a class="index" href="index.html" target="_self">Home</a></li></ul></nav></aside><footer><p>Copyright &copy;&nbsp;<a href="https://github.com/daix6">Shawn Dai</a></p></footer><script type="text/javascript" src="js/anchor.js" async></script></body></html>